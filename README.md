<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /README.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# DeriSock ![Build Status](https://github.com/psollberger/DeriSock/actions/workflows/DeriSock_BuildTest.yml/badge.svg)  [![NuGet Version](http://img.shields.io/nuget/v/DeriSock.svg?style=flat)](https://www.nuget.org/packages/DeriSock/) [![NuGet Downloads](https://img.shields.io/nuget/dt/DeriSock.svg)](https://www.nuget.org/packages/DeriSock/)

DeriSock is a client library that connects to the Deribit API via WebSocket.  
All methods and subscriptions found on https://docs.deribit.com are supported.

## Getting Started

To connect to the Deribit Network just instantiate a new instance of the `DeribitClient` class and call the `Connect` method to connect and the `Disconnect` method to disconnect.

<!-- snippet: readme-connect-disconnect -->
<a id='snippet-readme-connect-disconnect'></a>
```cs
var client = new DeribitClient(EndpointType.Testnet);
await client.Connect();

// do something

await client.Disconnect();
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L14-L22' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-connect-disconnect' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

To use a proxy, you can assign an `IWebProxy` instance to the default `ITextMessageClient` implementation (`TextMessageMessageWebSocketClient`) and pass it to the `DeribitClient` constructor.

<!-- snippet: readme-webproxy -->
<a id='snippet-readme-webproxy'></a>
```cs
// Use a web proxy to connect to the API

var messageSource = new TextMessageWebSocketClient(null);
messageSource.Proxy = new WebProxy("socks5://socks5.example.com:1080")
{
  Credentials = new NetworkCredential
  {
    UserName = "username",
    Password = "password"
  }
};

var clientWithProxy = new DeribitClient(EndpointType.Testnet, messageSource);
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L25-L40' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-webproxy' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The various methods are organized in categories (Authentication, Supporting, Market Data, ...) and scopes (Private, Public).

**Example:** Calling `GetOrderBook` from the `Public` scope.

<!-- snippet: readme-req-bbp-1 -->
<a id='snippet-readme-req-bbp-1'></a>
```cs
var response = await client.Public.GetOrderBook(
                 new PublicGetOrderBookRequest
                 {
                   InstrumentName = "BTC-PERPETUAL"
                 });

if (response.Error is not null) {
  // Handle errors returned by the API
  return;
}

if (response.Data is null) {
  // Something unexpected happened. 'Data' should not be null if 'Error' is null
  return;
}

var bestBidPrice = response.Data.BestBidPrice;
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L44-L63' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-req-bbp-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

**Example:** Calling `GetOrderBook` from the `MarketData` category.

<!-- snippet: readme-req-bbp-2 -->
<a id='snippet-readme-req-bbp-2'></a>
```cs
var response = await client.MarketData.PublicGetOrderBook(
                 new PublicGetOrderBookRequest
                 {
                   InstrumentName = "BTC-PERPETUAL"
                 });

if (response.Error is not null) {
  // Handle errors returned by the API
  return;
}

if (response.Data is null) {
  // Something unexpected happened. 'Data' should not be null if 'Error' is null
  return;
}

var bestBidPrice = response.Data.BestBidPrice;
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L67-L86' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-req-bbp-2' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

## Authentication

The library supports authentication via credentials and signature

### Authentication using Credentials

<!-- snippet: readme-auth-credentials -->
<a id='snippet-readme-auth-credentials'></a>
```cs
await client.Authentication.PublicLogin()
  .WithClientCredentials(
    "<client id",
    "<client secret>",
    "<optional state>",
    "<optional scope>");
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L90-L98' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-auth-credentials' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### Authentication using Signature

<!-- snippet: readme-auth-signature -->
<a id='snippet-readme-auth-signature'></a>
```cs
await client.Authentication.PublicLogin()
  .WithClientSignature(
    "<client id",
    "<client secret>",
    "<optional state>",
    "<optional scope>");
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L102-L110' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-auth-signature' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### Logout

When authenticated, you can logout like this (this is the only synchroneous method):

<!-- snippet: readme-auth-logout -->
<a id='snippet-readme-auth-logout'></a>
```cs
client.Authentication.PrivateLogout();
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L114-L117' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-auth-logout' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

**Note:** The server will automatically close the connection when you logout

## Subscriptions

The subscription system will choose `public/subscribe` or `private/subscribe` automatically.
If the client is authenticated it will use `private/subscribe`, if the client is not authenticated it will use `public/subscribe`.
This is also the reason why the subscription methods are not present in the `Public` or `Private` scopes.

<!-- snippet: readme-subscribtion-usage -->
<a id='snippet-readme-subscribtion-usage'></a>
```cs
// Subscribe to one or more channels.
var subscriptionStream = await client.Subscriptions.SubscribeBookChanges(
                           new BookChangesChannel
                           {
                             InstrumentName = "BTC-PERPETUAL",
                             Interval = NotificationInterval2._100ms
                           },
                           new BookChangesChannel
                           {
                             InstrumentName = "ETH-PERPETUAL",
                             Interval = NotificationInterval2._100ms
                           });

// Create a CancellationTokenSource to be able to stop the stream
// (i.e. unsubscribe from the channel(s))
var cts = new CancellationTokenSource();

// An IAsyncEnumerable<T> stream that will listen to incoming notifications as long as
// cts.Cancel(); is not called.
await foreach (var notification in subscriptionStream.WithCancellation(cts.Token)) {
  //Here you can do something with the received information.
  var bookChangeId = notification.Data.ChangeId;
}
```
<sup><a href='/src/DeriSock.DevTools/Snippets.cs#L121-L146' title='Snippet source file'>snippet source</a> | <a href='#snippet-readme-subscribtion-usage' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->
