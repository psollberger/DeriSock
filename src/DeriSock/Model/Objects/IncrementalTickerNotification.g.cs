// --------------------------------------------------------------------------
// <auto-generated>
//      This code was generated by a tool.
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
// </auto-generated>
// --------------------------------------------------------------------------
#pragma warning disable CS1591
#nullable enable
namespace DeriSock.Model
{
  using System;
  using DeriSock.Converter;
  
  /// <summary>
  /// </summary>
  [System.CodeDom.Compiler.GeneratedCodeAttribute("DeriSock.DevTools", "0.3.5")]
  public partial class IncrementalTickerNotification
  {
    /// <summary>
    /// <para>(Only for option) implied volatility for best ask</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("ask_iv")]
    public decimal? AskIv { get; set; }
    /// <summary>
    /// <para>It represents the requested order size of all best asks</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("best_ask_amount")]
    public decimal BestAskAmount { get; set; }
    /// <summary>
    /// <para>The current best ask price, <c>null</c> if there aren&apos;t any asks</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("best_ask_price")]
    public decimal BestAskPrice { get; set; }
    /// <summary>
    /// <para>It represents the requested order size of all best bids</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("best_bid_amount")]
    public decimal BestBidAmount { get; set; }
    /// <summary>
    /// <para>The current best bid price, <c>null</c> if there aren&apos;t any bids</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("best_bid_price")]
    public decimal BestBidPrice { get; set; }
    /// <summary>
    /// <para>(Only for option) implied volatility for best bid</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("bid_iv")]
    public decimal? BidIv { get; set; }
    /// <summary>
    /// <para>Current funding (perpetual only)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("current_funding")]
    public decimal? CurrentFunding { get; set; }
    /// <summary>
    /// <para>The settlement price for the instrument. Only when <c>state = closed</c></para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("delivery_price")]
    public decimal? DeliveryPrice { get; set; }
    /// <summary>
    /// <para>Estimated delivery price for the market. For more details, see Contract Specification &gt; General Documentation &gt; Expiration Price</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("estimated_delivery_price")]
    public decimal EstimatedDeliveryPrice { get; set; }
    /// <summary>
    /// <para>Funding 8h (perpetual only)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("funding_8h")]
    public decimal? Funding8H { get; set; }
    /// <summary>
    /// <para>Only for options</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("greeks")]
    public Greeks? Greeks { get; set; }
    /// <summary>
    /// <para>Current index price</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("index_price")]
    public decimal IndexPrice { get; set; }
    /// <summary>
    /// <para>Unique instrument identifier</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("instrument_name")]
    public string InstrumentName { get; set; } = string.Empty;
    /// <summary>
    /// <para>Interest rate used in implied volatility calculations (options only)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("interest_rate")]
    public decimal? InterestRate { get; set; }
    /// <summary>
    /// <para>The price for the last trade</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("last_price")]
    public decimal LastPrice { get; set; }
    /// <summary>
    /// <para>(Only for option) implied volatility for mark price</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("mark_iv")]
    public decimal? MarkIv { get; set; }
    /// <summary>
    /// <para>The mark price for the instrument</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("mark_price")]
    public decimal MarkPrice { get; set; }
    /// <summary>
    /// <para>The maximum price for the future. Any buy orders you submit higher than this price, will be clamped to this maximum.</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("max_price")]
    public decimal MaxPrice { get; set; }
    /// <summary>
    /// <para>The minimum price for the future. Any sell orders you submit lower than this price will be clamped to this minimum.</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("min_price")]
    public decimal MinPrice { get; set; }
    /// <summary>
    /// <para>The total amount of outstanding contracts in the corresponding amount units. For perpetual and futures the amount is in USD units, for options it is amount of corresponding cryptocurrency contracts, e.g., BTC or ETH.</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("open_interest")]
    public decimal OpenInterest { get; set; }
    /// <summary>
    /// <para>The settlement price for the instrument. Only when <c>state = open</c></para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("settlement_price")]
    public decimal? SettlementPrice { get; set; }
    /// <summary>
    /// <para>The state of the order book. Possible values are <c>open</c> and <c>closed</c>.</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("state")]
    public string State { get; set; } = string.Empty;
    /// <summary>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("stats")]
    public Statistics Stats { get; set; } = null!;
    /// <summary>
    /// <para>The timestamp (milliseconds since the Unix epoch)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("timestamp")]
    [Newtonsoft.Json.JsonConverter(typeof(MillisecondsTimestampConverter))]
    public DateTime Timestamp { get; set; }
    /// <summary>
    /// <para>Name of the underlying future, or <c>index_price</c> (options only)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("underlying_index")]
    public decimal? UnderlyingIndex { get; set; }
    /// <summary>
    /// <para>Underlying price for implied volatility calculations (options only)</para>
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [Newtonsoft.Json.JsonPropertyAttribute("underlying_price")]
    public decimal? UnderlyingPrice { get; set; }
  }
}
